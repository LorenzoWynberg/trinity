# Prompts Guide

How Trinity's prompt system works and how to customize it.

## Overview

Trinity uses templated prompts to communicate with Claude Code. Each command has its own prompt that produces structured JSON output.

```
CLI fills template → sends to Claude → Claude returns JSON → CLI parses and renders
```

---

## Prompt Structure

```
prompts/
├── templates/                    # User-facing command prompts
│   ├── init-analyze.md           # Analyze project during init
│   ├── init-claude-md.md         # Generate CLAUDE.md
│   ├── analyze.md                # Deep codebase analysis
│   ├── plan-add-init.md           # Create new PRD (no existing)
│   ├── plan-add-extend.md         # Add to existing PRD
│   ├── plan-refine.md             # Improve stories
│   └── story-execute.md          # Execute a single story
├── schemas/                      # Expected JSON response formats
│   ├── analyze.json
│   ├── plan-add.json
│   ├── plan-refine.json
│   └── ...
└── internal/                     # Internal command prompts
    ├── learn.md                  # Add learning
    ├── complete.md               # Mark story complete
    ├── add-story.md              # Add new story
    └── move-story.md             # Renumber story
```

---

## Template Format

Prompts use `{{placeholders}}` that CLI fills before sending:

```markdown
# Analyze Project

You are analyzing a software project.

## Project Info
- Path: {{project_path}}
- Stack: {{detected_stack}}

## Current Structure
{{file_tree}}

## Task
Analyze this project and suggest what to build next.

## Response Format
Respond with JSON matching this schema:
{{schema}}
```

---

## Schemas

Each prompt has a corresponding schema defining expected JSON output:

**`schemas/analyze.json`:**
```json
{
  "type": "object",
  "properties": {
    "stack": {
      "type": "object",
      "properties": {
        "language": { "type": "string" },
        "framework": { "type": "string" },
        "build_tool": { "type": "string" }
      }
    },
    "structure": {
      "type": "string",
      "description": "Brief description of project structure"
    },
    "suggestions": {
      "type": "array",
      "items": {
        "type": "object",
        "properties": {
          "title": { "type": "string" },
          "description": { "type": "string" },
          "priority": { "enum": ["critical", "high", "medium", "low"] }
        }
      }
    }
  }
}
```

---

## Key Prompts

### `analyze.md`

Deep codebase analysis. Used by `trinity analyze`.

**Input:**
- `{{project_path}}` - Absolute path to project
- `{{file_tree}}` - Directory structure
- `{{key_files}}` - Contents of important files (package.json, go.mod, etc.)

**Output:**
- Stack detection (language, framework, build tool)
- Structure summary
- Suggestions for what to build

---

### `init-claude-md.md`

Generate CLAUDE.md for the target project. Used by `trinity init`.

**Input:**
- `{{project_path}}` - Project path
- `{{project_analysis}}` - Output from analyze (stack, structure)

**Output:**
- CLAUDE.md content tailored to the project

**Required content:**
- Rules section with: "No AI attribution" rule (no "Generated by Claude", "Co-Authored-By: Claude", etc.)
- Project-specific guidance based on detected stack
- Build commands
- Architecture overview

---

### `plan-add-init.md`

Create a new plan from scratch. Used when no plan exists.

**Input:**
- `{{project_path}}` - Project path
- `{{project_analysis}}` - Output from analyze
- `{{user_description}}` - What user wants to build

**Output:**
- Full PRD with phases, epics, stories
- Proper IDs and dependencies

---

### `plan-add-extend.md`

Add to existing PRD. Used when PRD exists.

**Input:**
- `{{existing_prd}}` - Current PRD structure
- `{{user_description}}` - What to add

**Output:**
- Analysis of where it fits
- Suggestions for placement
- Generated story/epic with proper ID

---

### `story-execute.md`

Execute a single story. This is the main implementation prompt.

**Input:**
- `{{story}}` - Full story object (title, intent, acceptance)
- `{{context}}` - Related learnings, recent activity
- `{{project_structure}}` - File tree
- `{{related_code}}` - Existing related code

**Output:**
- Implementation steps
- Files to create/modify
- Tests to write

---

## Internal Prompts

Used by `trinity internal` commands. Claude Code calls these.

### `learn.md`

Add a learning to the database.

**Input:**
- `{{content}}` - Learning content
- `{{tags}}` - Associated tags
- `{{existing_learnings}}` - Current learnings (to check duplicates)

**Behavior:**
- Checks for duplicates
- Formats consistently
- Suggests tags if not provided

### `complete.md`

Mark a story as complete.

**Input:**
- `{{story}}` - Story being completed
- `{{changes}}` - Files changed, tests written

**Behavior:**
- Validates all acceptance criteria met
- Updates dependency graph
- Logs to activity

---

## Token Optimization

Prompts are designed for minimal token usage:

1. **Minimal context** - Only send relevant parts of PRD, not entire thing
2. **Structured output** - JSON only, no prose
3. **Schema constraints** - Claude knows exact format
4. **Incremental loading** - Load more context only when needed

**Bad prompt:**
```
Please analyze this project and give me a detailed report about what you find...
```

**Good prompt:**
```
Analyze project. Respond with JSON:
{"stack": {...}, "suggestions": [...]}
```

---

## Customization

Prompts are embedded in the CLI binary via `go:embed`. To customize:

1. **Fork and modify** - Change prompts in `prompts/` directory
2. **Rebuild CLI** - `go build ./cmd/trinity`

Future: Per-project prompt overrides in `~/.trinity/projects/<hash>/prompts/`
